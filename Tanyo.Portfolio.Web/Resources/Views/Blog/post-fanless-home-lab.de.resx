<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fanless-content-intro" xml:space="preserve">
    <value>In diesem Beitrag erzähle ich Ihnen, wie ich einen Heimserver ohne Lüfter oder rotierende Teile gekauft und eingerichtet habe. In den vergangenen Beiträgen habe ich über den Test-Cluster-Server aus Raspberry PI ARM-Boards gesprochen, den ich nur zum Spaß und zum Testen einiger Technologien verwendet habe. Dann zerlegte ich es und benutzte es für die Heimautomatisierung.

Jetzt sind die Dinge keine Tests mehr und ich beschloss, etwas Richtiges zu tun. Ich habe 1.500 BGN in einen Server aus China investiert, was sich als ziemlich gut herausstellte. Die Wahrheit ist, dass China das globale Kraftpaket für Hardware ist und der Entwicklung um Jahre voraus ist. Es ist eine Maschine der neuen Generation, die noch nicht einmal Treiber für eines der Teile hat. Es ist ein großer Kühler, der einen leistungsstarken i7-Prozessor, eine Terabyte-SSD-Festplatte und fast 70 Gigabyte RAM beherbergt.

Es kann auch als Router verwendet werden. Es hat 5 Buchsen für LAN-Kabel und kann darauf pfsense installieren.

Hier ist seine Konfiguration:
Prozessor: 2,5 G i7 1165G7
Arbeitsspeicher: 68 GB DDR4
Schwer: 1 TB NVMe

Ich verwende es für einen Medien- und Webserver sowie für eine Heim-TV-Grafikumgebung und eine Spieleplattform. Alles in allem...

Sie können es auf dem Bild unten sehen. Ich habe 2 Festplatten daran angeschlossen und erwarte bald zwei weitere. Ich betreibe eine Website mit Docker und Nginx Proxy Manager.

Hier ist ein Bild:</value>
  </data>
  <data name="fanless-content-outro" xml:space="preserve">
    <value>Sie sehen, wie nützlich der Heimserver ist. Ich habe auch eine Verbesserung der Geschwindigkeit der Websites festgestellt, die ich anstelle des von mir verwendeten Hostings betreibe. Negativ würde ich sagen, dass es viel schwieriger und zeitaufwändiger ist, einen Heimserver zu verwenden, anstatt zu hosten. Das Hosting gibt Ihnen die Dinge bereits fertig und Sie müssen nicht die Fehler machen, die sie bereits gelöst haben. Positiv würde ich sagen, dass man viel mehr Freiheit und Eigenverantwortung hat, sich nicht mit dem Helpdesk herumschlagen muss etc.

Im Allgemeinen ist das Hosting für Produktionswebsites sicherer, aber auf der anderen Seite gibt es weniger Verwaltungsaufwand und jemand anderes hat Ihre Daten.

Ich hoffe, es hat euch gefallen. Dies ist nur der Anfang einer Reihe, die ich für den Server ausführen werde. Es wird bald einen Beitrag über Grafana und andere Technologien geben.</value>
  </data>
  <data name="fanless-content-section1" xml:space="preserve">
    <value>Als Geräte besteht mein Heimnetzwerk aus persönlichen Geräten wie Laptop, Telefon und Drucker. Die Geräte, die ich für den Server verwende, sind der Server selbst, zwei Festplatten, aus denen bald mehr werden, und ein Router.

Auf dem Server habe ich die unfreie Debian 11-Version + die grafische KDE-Oberfläche installiert. Ich speichere die gesamte Software in einer sh-Datei, die wiederverwendet werden kann. Der Server verwendet Docker, um die Sites als Container auszuführen, deren Bilder ich derzeit auf GitHub halte.

Es gibt einen Nginx-Proxy-Manager, der Domänennameneinträge für die in Docker geöffneten Ports erstellt und die Einträge Port 80 HTTP oder 443 HTTPS auf dem Router zuordnet. Die Ports 80:80 und 443:443 werden vom Router aus geöffnet, sodass, wenn jemand einen Domainnamen schreibt, dieser dem entsprechenden Container zugeordnet werden kann.

Unten sehen Sie eine Karte der Geräte im Heimnetzwerk, und es gibt noch ein paar weitere, die nicht wichtig sind und daher nicht enthalten sind:</value>
  </data>
  <data name="fanless-content-section2" xml:space="preserve">
    <value>Die Software und Container, die ich auf dem Laptop installiert habe, orientieren sich hauptsächlich an:
- Anlagen- und Behälterüberwachung
- Buchhaltung und Bürotätigkeiten
- Aufbewahrung von Backups der Sites und des Systems
- Starten von Websites
- Streaming von Medien wie Spielen, Filmen, Musik und Büchern
- Spiele spielen

Die Website, die Sie gerade ansehen, befindet sich auf dem Server und befindet sich in Bulgarien. Ein paar weitere Websites, die mit virtuellem Speed-Dating zu tun haben, meine Firma und kleine Experimente sind auch dabei. Dies sind handgefertigte Applikationen von mir.

Als fertige Anwendungen verwende ich:
- Oddo ERP-System für die Buchhaltung und Organisation von Dokumenten und anderen Dingen über das Unternehmen
- Nginx Proxy Manager zum Erstellen interner Domänennamen für Container und deren Offenlegung über den Router.
- Plex Media Center zum Ansehen von Filmen und Musik, wenn ich sie heruntergeladen habe, und ich habe es auch auf meinem Telefon, sodass ich es auch unterwegs verwenden kann.
- Grafana für System- und Containerüberwachung. Es gibt einige ziemlich schöne Grafiken, die ich bald in einem zukünftigen Beitrag zeigen werde.
- jsWiki, mit dem ich Projektdokumentationen erstelle.
- Portainer, mit dem ich Container verwalte
- Andere Container, die andere Zwecke haben, wie Searchxng zum Suchen im Internet anstelle von Google, Caliber-Web zum Verwalten von Büchern, Jellyfish als Alternative zu Plex, Map-Container, mit dem ich ein Dashboard für alle Websites erstelle und leichter darauf zugreifen kann ein Platz.

Ich habe neben Docker noch andere Software auf dem Server installiert. Für Spiele verwende ich Mame und den PCSXe-Emulator.

Sie können einen Blick auf die Software- und Gerätekarte werfen, um eine ungefähre Vorstellung davon zu bekommen, worum es geht:</value>
  </data>
  <data name="fanless-title" xml:space="preserve">
    <value>Ein Heimlabor ohne Ventilatoren</value>
  </data>
</root>