<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fanless-content-intro" xml:space="preserve">
    <value>В този пост ще ви разкажа за това как закупих и обурудвах домашен сървър, който няма никакви вентилатори и въртящи части в себе си. В миналите постове разказах за тестовия клъстърен сървър от Raspberry PI ARM платки, който ползвах просто за забавление и тестване на някой технологии. След това го разглобих и ползвах за автомация на дома. 

Сега вече нещата не са тестови и реших да направя нещо истинско. Инвестирах 1500лева във сървър от Китай, който се оказа доста добър. Истината е, че Китай са си глобалната сила в хардуера и са години напред. Това е машина от ново поколение, за която все още няма дори излязли драйвери за някой от частите. Представлява един голям охладител, в който са разположени мощен i7 процесор, терабайт SSD хард и почти 70 гигабайта оперативна памет.

Може да се ползва и като рутер. Има 5 гнезда за Лан кабели и може да се инсталира pfsense на него.

Ето и конфигурацията му:
Процесор: 2.5G i7 1165G7
RAM: 68GB DDR4
Hard: 1TB NVMe

Ползвам го за Медиен и Уеб сървър, както и графична среда на телевизора удома и игрална платформа. Общо взето всичко...

Ето тук долу можете да го видите на картинката. Закачил съм към него 2 хард диска и очаквам скоро още два. Пускам сайтовече чрез Docker i Nginx Proxy Manager.

Ето картинка:</value>
  </data>
  <data name="fanless-content-outro" xml:space="preserve">
    <value>Виждате колко полезен е домашния сървър. Освен това забелязах и подобрение на бързината на уебсайтовете, които пускам вместо хостинга, който ползвах. Като негатив бих казал, че е доста по-трудемко и времеотнемащо да ползваш домашен сървър вместо хостинг. Хостинга ти дава нещата вече готови и не е нужно да допускаш грешките, които те вече са решили. Като позитив бих казал, че имаш доста по-голяма свобода и чувство за собственост, не е нужно да се разправяш със helpdesk и тн.

Като цяло хостинга е по-безопасен за production уебсайтове, но от друга страна управлението е по-малко и някой друг човек разполага със данните ти.

Надявам се че ви е харесало. Това е само начало от поредица, която ще пускам за сървъра. Скоро ще има пост за Grafana i други технологии.</value>
  </data>
  <data name="fanless-content-section1" xml:space="preserve">
    <value>Като устройства домашната ми мрежа се състои от лични устройства като Лаптоп, Телефон и Принтер. Устройствата, които ползвам за сървъра са Самият сървър, два Хард диска, които скоро ще станат повече и Рутер.

На сървъра съм Инсталирал Debian 11 non-free версия + KDE графичен интерфейс. Целия софтуер запазвам във sh файл, койото може да се преизползва. Сървърът използва Docker за да пуска сайтовете като контейнери, на които images за момента запазвам в GitHub. 

Има Nginx Proxy manager, който създава записи на домейн имена спрямо портовете отворени в Docker и мапва записите с порт 80 HTTP или 443 HTTPS на рутера. От рутера са отворени портовете 80:80 и 443:443, за да може, когато някой човек изпише домейн името да му се мапне към съответния контейнер.

Долу можете да видите карта на устройствата в домашната мрежа, като има още някои, които не са важни и затова не са включени:</value>
  </data>
  <data name="fanless-content-section2" xml:space="preserve">
    <value>Софтуера и контейнерите, които съм инсталирал на лаптопа главно са ориентиран към:
- Мониторинг на системата и контейнерите
- Счетоводство и офис работа
- Запазване на бекъпи на сайтовете и системата
- Пускане на уебсайтове
- Стриймване на медиа като игри, филми, музика и книги
- Играене на игри

Сайта, който в момента разглеждате стои на сървъра, а локацията му е в България. Още няколко уебсайта, които са свързани със виртуални бързи срещи, фирмата ми и малки експерименти соят на него също. Това са ръчно изработени апликации от мен.

Като готови апликации ползвам:
- ERP система Oddo за счетоводство и организация на документи и други неща по фирмата
- Nginx Proxy Manager за създаване на вътрешни домейн имена за контейнерите и експузването им през рутера.
- Plex медиен център за разглеждане на филми и музика ако имам свалени, като го имам също и на телефона, така че като съм на път също мога да го ползвам.
- Grafana за мониторинг на системата и контейнерите. Има доста хубави графики, които ще покажа скоро във следващ пост.
- jsWiki който ползвам за създаване на документации на проекти.
- Portainer, който ползвам за управление на контейнерите
- Други контейнери, които са с различни цели като Searchxng за търсене в интернет вместо Google, Calibre-web за управление на книги, Jellyfish като алтернатива на Plex, Map контейнер, с който си създавам dashboard за всички сайтове и по-лесно мога да ги достъпвам от едно място.

На сървъра съм инсталирал и други софтуери освен Docker. За игри ползвам Mame i PCSXe емулатор.

Може да разгледате карта на софтуера и устройствата, така че да получите горе долу представа какво представлява:</value>
  </data>
  <data name="fanless-title" xml:space="preserve">
    <value>Домашна лаборатория без вентилатори</value>
  </data>
</root>