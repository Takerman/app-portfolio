<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fanless-content-intro" xml:space="preserve">
    <value>In this post, I'll tell you about how I purchased and set up a home server that doesn't have any fans or rotating parts in it. In the past posts, I talked about the test cluster server made of Raspberry PI ARM boards, which I used just for fun and testing some technologies. Then I took it apart and used it for home automation.

Now things are no longer in test and I decided to do something for real. I invested $800 in a server from China, which turned out to be quite good. The truth is that China is the global powerhouse in hardware and is years ahead. It's a new generation machine that doesn't even have drivers for any of the parts out yet. It is a large cooler that houses a powerful i7 processor, a terabyte of SSD hard drive and almost 70 gigabytes of RAM.

It can also be used as a router. It has 5 sockets for LAN cables and can install pfsense on it.

Here is its configuration:
Processor: 2.5G i7 1165G7
RAM: 68GB DDR4
Hard: 1TB NVMe

I use it for a Media and Web server as well as a home TV graphics environment and gaming platform. All in all...

You can see it in the picture below. I have attached 2 hard drives to it and expect two more soon. I run a website using Docker and Nginx Proxy Manager.

Here is a picture:</value>
  </data>
  <data name="fanless-content-outro" xml:space="preserve">
    <value>You see how useful the home server is. I have also noticed an improvement in the speed of the websites I run instead of the hosting I was using. As a negative, I would say that it is much more difficult and time consuming to use a home server instead of hosting. The hosting gives you things already ready and you don't have to make the mistakes that they have already solved. As a positive, I would say that you have a lot more freedom and a sense of ownership, you don't have to deal with the helpdesk, etc.

In general, hosting is safer for production websites, but on the other hand, there is less management and someone else has your data.

I hope you liked it. This is just the beginning of a series I will be running for the server. There will be a post soon about Grafana and other technologies.</value>
  </data>
  <data name="fanless-content-section1" xml:space="preserve">
    <value>As devices, my home network consists of personal devices such as Laptop, Phone and Printer. The devices I use for the server are the server itself, two hard drives, which will soon become more, and a router.

On the server I have installed Debian 11 non-free version + KDE graphical interface. I save all the software in an sh file that can be reused. The server uses Docker to run the sites as containers, the images of which I currently keep on GitHub.

There is an Nginx Proxy manager that creates domain name records against the ports open in Docker and maps the records to port 80 HTTP or 443 HTTPS on the router. Ports 80:80 and 443:443 are opened from the router, so that when someone writes a domain name, it can be mapped to the corresponding container.

Below you can see a map of the devices on the home network, and there are a few more that are not important and therefore not included:</value>
  </data>
  <data name="fanless-content-section2" xml:space="preserve">
    <value>The software and containers I have installed on the laptop are mainly oriented towards:
- System and container monitoring
- Accounting and office work
- Keeping backups of the sites and the system
- Launching websites
- Streaming media such as games, movies, music and books
- Playing games

The site you are currently viewing is on the server, and its location is in Bulgaria. A few more websites that are related to virtual speed dating, my company and small experiments are on it too. These are handmade appliqués by me.

As ready-made applications I use:
- Oddo ERP system for accounting and organization of documents and other things about the company
- Nginx Proxy Manager for creating internal domain names for containers and exposing them through the router.
- Plex media center for watching movies and music if I have them downloaded, and I also have it on my phone, so when I'm on the go I can use it too.
- Grafana for system and container monitoring. There are some pretty nice graphics that I will show soon in a future post.
- jsWiki which I use to create project documentation.
- Portainer, which I use to manage containers
- Other containers that have different purposes such as Searchxng for searching the Internet instead of Google, Caliber-web for managing books, Jellyfish as an alternative to Plex, Map container, with which I create a dashboard for all sites and can more easily access from one place.

I have other software installed on the server besides Docker. For games I use Mame and PCSXe emulator.

You can take a look at the software and devices map to get a rough idea of what it's all about:</value>
  </data>
  <data name="fanless-title" xml:space="preserve">
    <value>Fnaless Home lab</value>
  </data>
</root>